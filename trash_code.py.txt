import multiprocessing
import os
import random
import time
import psutil
import dd.cudd as _bdd
from qiskit.converters import circuit_to_dag
import numpy as np
import math

from cir_input.circuit_DG import CreateDGfromQASMfile

import signal
from contextlib import contextmanager

from cir_input.circuit_process import get_gates_number
from multiprocessing import Pool, Process, Queue
from joblib import Parallel, delayed


def apply_bv_cir(self, dag, nqubit, noise=0):
    cnt = 0
    # nqubit = 10000
    for i in range(nqubit-1):
        self.apply_H(i)
        print("h"+str(i)+" "+str(len(self.Fd)))
        self.check_zero()
        self.bound_bdd()
        if cnt < noise:
            self.apply_noise(i, nqubit)
            cnt += 1
    self.apply_X(nqubit-1)
    self.apply_H(nqubit-1)
    for i in range(nqubit-1):
        self.apply_CNOT(i, nqubit-1)
        self.check_zero()
        self.bound_bdd()
        print("cx"+str(i)+" "+str(len(self.Fd)))
        print("h"+str(i)+" "+str(len(self.Fd)))
        self.apply_H(i)
        self.check_zero()
        self.bound_bdd()

def fast_noise_measure(self, str, nqubit, nnoise, fault_model='depolorize'):
    coef = {}
    result = 0
    if fault_model == "depolorize":
        for j in range(nnoise):
            coef[j] = {}
            coef[j][0] = [[1 - self.p, 0], [0, 1 - self.p]]
            coef[j][1] = [[0, self.p/3], [self.p/3, 0]]
            coef[j][2] = [[0, -1.0j*self.p/3], [1.0j*self.p/3, 0]]
            coef[j][3] = [[1/3*self.p, 0], [0, -1/3*self.p]]
    elif fault_model == 'real':
        dt = 25
        T1 = 200
        T2 = 20
        Tphi = 2*T1*T2/(2*T1-T2)
        choice = random.randint(0, 1)
        # amplitude damping
        if choice == 0:
            for j in range(nnoise):
                coef[j] = {}
                coef[j][0] = [[1, 0], [0, math.exp(-dt/(2*math.pi))]]
                coef[j][1] = [
                    [0, math.sqrt(1-math.exp(-dt/(math.pi)))], [0, 0]]
                coef[j][2] = [[0, 0], [0, 0]]
                coef[j][3] = [[0, 0], [0, 0]]
        else:
            for j in range(nnoise):
                coef[j] = {}
                coef[j][0] = math.exp(-dt/(2*Tphi)) * [[1, 0], [0, 1]]
                coef[j][1] = math.sqrt(
                    1-math.exp(-dt/Tphi)) * [[1, 0], [0, 0]]
                coef[j][2] = math.sqrt(
                    1-math.exp(-dt/Tphi)) * [[0, 0], [0, 1]]
                coef[j][3] = [[0, 0], [0, 0]]

    for i in range(4 ** nnoise):
        dic = {}
        num = i
        tmp_coef = 1.0

        for j in range(nnoise):
            tmp = num % 4
            if tmp == 0:
                dic[r'q{i}'.format(i=self.nd[j][0])] = False
                dic[r'q{i}'.format(i=self.nd[j][1])] = False
                tmp_coef *= coef[j][0][0][0] + coef[j][1][0][0] + \
                    coef[j][2][0][0]+coef[j][3][0][0]
            if tmp == 1:
                dic[r'q{i}'.format(i=self.nd[j][0])] = False
                dic[r'q{i}'.format(i=self.nd[j][1])] = True
                tmp_coef *= coef[j][0][0][1] + coef[j][1][0][1] + \
                    coef[j][2][0][1]+coef[j][3][0][1]
            if tmp == 2:
                dic[r'q{i}'.format(i=self.nd[j][0])] = True
                dic[r'q{i}'.format(i=self.nd[j][1])] = False
                tmp_coef *= coef[j][0][1][0] + coef[j][1][1][0] + \
                    coef[j][2][1][0]+coef[j][3][1][0]
            if tmp == 3:
                dic[r'q{i}'.format(i=self.nd[j][0])] = True
                dic[r'q{i}'.format(i=self.nd[j][1])] = True
                tmp_coef *= coef[j][0][1][1] + coef[j][1][1][1] + \
                    coef[j][2][1][1]+coef[j][3][1][1]
            num = int((num - tmp) / 4)
        for j in range(nqubit):
            dic[r'q{i}'.format(i=self.qd[j])] = (str[j] == '1')

        a = to_int_list([bdd.to_expr(bdd.let(dic, self.Fa[j]))
                        for j in range(self.r)])
        b = to_int_list([bdd.to_expr(bdd.let(dic, self.Fb[j]))
                        for j in range(self.r)])
        c = to_int_list([bdd.to_expr(bdd.let(dic, self.Fc[j]))
                        for j in range(self.r)])
        d = to_int_list([bdd.to_expr(bdd.let(dic, self.Fd[j]))
                        for j in range(self.r)])

        num_a = list_to_num(a)
        num_b = list_to_num(b)
        num_c = list_to_num(c)
        num_d = list_to_num(d)

        co = ((num_d - num_b) + (num_c - num_a)
                * 1.0j) / (np.sqrt(2)) ** self.k
        result += co * tmp_coef

    return result
